package com.tj703.webapp_server_study;

import org.mindrot.jbcrypt.BCrypt;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.Arrays;

/*
입문 개념
해시(Hash)(해시값Hash Value): 데이터를 짧고 고유한 값으로 바꾼 "결과물"입니다. 예를 들어, 고유한 숫자나 알파벳의 조합으로 변환한 것이 해시.
해시 함수(Hash Function): 데이터를 입력받아 고정된 길이의 해시값을 "출력하는 함수". 예를 들어, 어떤 문자열을 넣으면 항상 같은 길이의 고유한 해시값을 리턴합니다.
해싱(Hashing): 데이터를 해시값으로 변환하는 "과정"입니다. 예를 들어, 문장을 해시 함수에 넣으면 그 문장이 고유한 해시값으로 바뀝니다.


암호화 방식에 대한 기본적인 개념과 시스템에서 사용자 비밀번호를 안전하게 처리하는 방식에 대하여.

암호화의 기본 방식
1. 단방향 암호화 (Hashing)
단방향 암호화는 한 방향으로만 데이터를 변환하는 방식입니다. 즉, 원래 값을 **복호화(되돌리는 과정)**할 수 없습니다. 변환된 값을 다시 원래 값으로 바꾸는 것이 불가능하므로, 이를 **해시(Hashing)**라고도 합니다.
사용 예: 사용자 비밀번호 저장
사용자가 1234라는 비밀번호를 입력하면, 시스템은 이 값을 단방향 해시 함수를 사용해 해시 값으로 변환합니다. 예를 들어, 1234는 e99a18c428cb38d5f260853678922e03 같은 고유한 해시 값으로 변환됩니다.
이 해시 값은 원본 비밀번호로 복호화할 수 없습니다. 즉, e99a18c428cb38d5f260853678922e03이라는 값만 가지고는 원래의 1234를 알 수 없지만, 이 값을 통해 시스템은 사용자가 입력한 비밀번호가 정확한지 비교할 수 있습니다.

2. 양방향 암호화 (Encryption/Decryption)
양방향 암호화는 데이터를 암호화한 후, 복호화(되돌리는 과정)가 가능한 방식입니다.
양방향 암호화는 데이터를 복호화할 수 있기 때문에, 원본을 복원해야 할 때 사용합니다. 예를 들어, 암호화된 이메일 내용이나 파일을 복호화할 때 사용
이 방식에서는 공개키와 비공개키를 사용하여 데이터를 암호화하고 복호화합니다.
    공개키 암호화: 데이터를 암호화할 때 공개키를 사용하고, 복호화할 때 비공개키를 사용합니다. 비공개키는 비밀로 유지됩니다.
    비공개키 암호화: 데이터를 암호화할 때 비공개키를 사용하고, 복호화할 때 공개키를 사용합니다.

3. 사용자 비밀번호 처리 방식
비밀번호를 처리할 때 단방향 해시 방식을 사용해야 하는 이유는 보안 때문입니다.
개발자나 서버가 사용자의 비밀번호를 알 수 없으면서도, 입력한 비밀번호가 맞는지 확인할 수 있는 방법을 제공해야 하기 때문입니다.

- 사용자 비밀번호를 해시 처리
사용자가 1234라는 비밀번호를 입력하면, 서버는 이 값을 단방향 해시 함수를 이용해 변환합니다.
예를 들어, 1234는 e99a18c428cb38d5f260853678922e03와 같은 해시 값으로 변환됩니다.
서버에는 이 해시 값만 저장됩니다. 즉, 실제 비밀번호는 서버에 저장되지 않고, 그 대신 해시 값만 저장됩니다.
서버나 개발자는 사용자가 입력한 비밀번호가 무엇인지 알 수 없습니다.

- 사용자가 로그인할 때
사용자가 다시 1234라는 비밀번호를 입력하면, 서버는 입력된 비밀번호를 다시 해시 함수에 넣어서 새로운 해시 값을 생성합니다.
서버는 이미 저장된 해시 값과 새로 생성된 해시 값을 비교합니다. 두 값이 일치하면 사용자가 맞는 비밀번호를 입력한 것으로 간주합니다.
예시
    비밀번호 입력: 사용자가 1234를 입력합니다.
    해시 처리: 서버는 이 비밀번호를 해시 함수로 변환하여 해시 값 (e99a18c428cb38d5f260853678922e03)을 생성합니다.
    비교: 서버는 데이터베이스에 저장된 해시 값 (e99a18c428cb38d5f260853678922e03)과 새로 생성된 해시 값을 비교합니다.
    일치하면 로그인 성공. 일치하지 않으면 로그인 실패.

 MD5, SHA1, SHA2는 모두 단방향 해시 함수에 속하는 알고리즘들입니다.
 이들이 모두 해시 함수의 복잡성에서 차이가 나며, 각 해시 함수는 그 자체로 입력값을 고유한 고정된 길이의 값(즉, 해시 값)으로 변환하는 역할을 합니다.
 이들의 차이는 주로 해시값의 길이와 암호화 복잡도에 있습니다
입력값이 똑같으면, 결과도 똑같이 나온다는 것이 바로 단방향 해시 함수의 기본 원리
그래서 사용자가 1234라는 비밀번호를 입력할 때, 서버는 이 값을 해시 처리하여 저장하고, 나중에 사용자가 다시 1234를 입력하면 같은 해시 값이 나오므로 비밀번호가 맞는지 비교할 수 있습니다

사용자가 1234라는 비밀번호를 입력한다고 가정해봅시다.
MD5 해시 함수는 이를 e99a18c428cb38d5f260853678922e03로 변환합니다.
SHA1 해시 함수는 이를 2ef7bde608ce5404e97d5f042f95f89f1c232871로 변환합니다.
SHA2 해시 함수는 이를 ef7bde608ce5404e97d5f042f95f89f1c232871와 같은 방식으로 변환할 것입니다.

Bcrypt가 이 문제를 해결하는 핵심은 **솔트(salt)**와 **비용 인자(cost factor)**입니다.
Bcrypt의 주요 특징: 솔트(Salt) 사용 / 비용 인자(Cost factor) 사용 / 느린 연산 속도

Bcrypt 해시: bcrypt$2a$10$randomSalt123$<encrypted_value>

1) 솔트(Salt) 사용
솔트는 해시 함수에 추가되는 랜덤한 값입니다. 이 값을 추가함으로써 같은 입력값에 대해서도 서로 다른 해시 값을 생성할 수 있게 됩니다.
예를 들어, 솔트가 randomSalt123라면, Bcrypt는 1234randomSalt123을 해시하여 다른 결과를 만듭니다.
같은 비밀번호를 입력하더라도, 사용자마다 서로 다른 솔트가 사용되기 때문에 서로 다른 해시 값이 생성됩니다.
물론 서버에는 솔트가 공개되어 있으니, 그것을 안다면 항상 같은 해시값을 얻을 수 있긴하다. (솔트가 공개되더라도 그 자체만으로 해시값을 쉽게 구할 수 없다는 점이 핵심)

2) 비용 인자(Cost Factor) 사용
비용 인자는 Bcrypt의 연산 속도를 조절하는 중요한 요소입니다.
비용 인자는 해시 연산을 얼마나 복잡하게 만들지를 결정합니다.
이 값은 일반적으로 2의 n승 형태로 설정됩니다. 즉, 비용 인자가 10이라면, Bcrypt는 해시 계산을 2^10 = 1024번 반복하여 수행합니다.

예를 들어, 사용자 A는 randomSalt123 솔트로 해시되고, 사용자 B는 anotherSalt456이라는 솔트로 해시됩니다. 결과적으로, 이 두 사용자의 해시 값은 전혀 다르게 나옵니다.

솔트 덕분에 해시 충돌을 방지하고, 비용 인자 덕분에 연산 시간을 늘려서 공격을 어렵게 만듭니다.



 */

/*
MD5, SHA1, SHA2  -- 현장에서 안씀. 뚫림
BCrypt (소금 salt == 암호화키)  --
#AES(대칭키), RSA(비대칭키)

암호화(encryption)와 복호화(decryption)는 정보 보호의 중요한 개념

> 암호화(encryption)
   의도적으로 복호화가 불가능하도록 설계된 방식입니다.
   예를 들어, 해시 함수(Hashing) 방식은 한 번 암호화하면 원래의 데이터를 복원할 수 없도록 만듭니다.
   암호화는 대개 공개키 암호화(public-key encryption)나 비밀키 암호화(symmetric-key encryption) 방식으로 이루어집니다.
   대표적인 예로 SHA-256 같은 해시 알고리즘이 있습니다. 이 방식은 데이터를 변환하여 해시값을 생성하지만, 그 해시값으로부터 원본 데이터를 추출하는 것은 불가능
> 복호화(Decryption):
   암호화된 데이터를 다시 원래의 데이터(평문)로 복원하는 과정


1. 암호화 방식의 유형에 따른 분류
   단방향 암호화 (One-way encryption)
단방향 암호화는 한 번 암호화하면 원래 데이터를 다시 복원할 수 없는 방식입니다. 즉, 암호화된 데이터를 다시 원래의 데이터로 되돌리는 것이 불가능합니다.
예: MD5, SHA-1, SHA-2, BCrypt (비밀번호 해싱).
특징: 원본 데이터 복원이 불가능하며, 해시값을 통한 데이터 일치 여부만 확인할 수 있습니다.

대칭키 암호화 (Symmetric Key Encryption):
암호화와 복호화에 동일한 키를 사용하는 방식입니다.
예: AES (Advanced Encryption Standard).
특징: 속도가 빠르고, 대용량 데이터 암호화에 효율적이지만, 키 관리가 어려울 수 있습니다.

비대칭키 암호화 (Asymmetric Key Encryption):
공개키와 개인키 두 개의 키를 사용하는 방식입니다.
예: RSA, ECC (Elliptic Curve Cryptography), Diffie-Hellman.
특징: 공개키는 암호화에 사용되고, 개인키는 복호화에 사용됩니다. 대체로 암호화 속도가 느리고, 주로 키 교환, 인증 및 디지털 서명에 사용됩니다.


2. 용도에 따른 분류
데이터 암호화:
실제 데이터를 암호화하는 데 사용되는 알고리즘입니다.
예: AES (대칭키), RSA (비대칭키).
특징: 파일, 메시지, 네트워크 통신 등에서 데이터를 암호화하여 보안을 강화합니다.

키 교환 및 공개키 기반 암호화:
보통 키를 안전하게 교환하거나 공개키/개인키 기반으로 암호화 및 서명을 수행합니다.
예: RSA, Diffie-Hellman, ECC.
특징: 네트워크 상에서 안전하게 비밀키를 공유하거나 인증서를 사용해 신뢰를 구축합니다.

비밀번호 해싱:
비밀번호를 저장할 때 사용되는 알고리즘으로, 원본 비밀번호를 복호화할 수 없도록 안전하게 처리합니다.
예: BCrypt, PBKDF2.
특징: 사용자 비밀번호를 안전하게 해싱하여 저장하고, 해시값을 비교하여 인증합니다.

 */

public class L27HashCode {
    public static void main(String[] args) throws Exception {
        // 해시코드 만드는 방법:  "1234" -> 수로 바꿔서 더하고 빼고 이리저리 바꾸서 ...-> 특정 길이의 값을 만듬
        // 해시코드의 문제점;  같은 값이 존재할 수 있음. 중간연산 방식을 알아내면 역추리 할 수 있음

        // MD5, SHA1, SHA2  -- 현장에서 안씀. 뚫림
        MessageDigest digest = MessageDigest.getInstance("MD5");
        String pw = "안녕"; // 문자를 수로 바꿔야 하므로, 문자표의 번호로 만들어야 함
        byte[] pwBytes = pw.getBytes();
        System.out.println(Arrays.toString(pwBytes)); // [-20, -107, -120, -21, -123, -107]
        System.out.println(new BigInteger(1, pwBytes).toString(16)); // ec9588 eb8595
        // "안" (utf8변환)== "0xEC 0x95 0x88" == "-20, -107, -120"
        // 음수인 이유  문자 인코딩 방식에 따라 바이트 값이 다르게 해석되기 때문.
        // 기본 인코딩은 대개 UTF-8이므로, "안녕"을 UTF-8로 변환하면,
        // UTF-8 인코딩은 가변 길이 인코딩 방식으로, 각 문자를 1바이트에서 최대 4바이트로 인코딩합니다.
        // 한글 "안"과 "녕"은 각각 3바이트로 인코딩됩니다. UTF-8에서 한글은 음수 값을 가질 수 있는 범위에 해당하는 바이트들을 사용할 수 있습니다.
        // 이 바이트들은 부호 있는 값(signed byte)로 표현될 수 있으며, 이로 인해 바이트 값이 음수로 보입니다.

        ///  MD5
        byte[] pwMD5 = digest.digest(pwBytes);
        System.out.println(Arrays.toString(pwMD5)); // [-17, 28, 81, 28, -98, -5, -110, 89, 67, -113, 9, -118, -1, -108, 7, 64]
        // bigint는 길이가 없는 정수(string과 비슷)를 써야 한다.
        // int는 4바이트로 하겠다고 크기를 고정. long는 8바이트로 고정.
        // bigint는 길이 제한을 걸지 않은 것. (크기가 기본 8바이트였다가, 계속 추가해서 커질 수 있음)
        BigInteger pwMD5BigInt = new BigInteger(1, pwMD5);
        System.out.println(pwMD5BigInt); // 317832520447403078026945168175332067136
        System.out.println(pwMD5BigInt.toString(16)); // ef1c511c9efb9259438f098aff940740
        /*
        Byte는 8비트 크기의 데이터 단위로, 일반적으로 두 가지 방식으로 해석됩니다:
        부호 있는 (Signed) Byte: 이 경우, -128에서 127까지의 값을 가질 수 있습니다.
             부호 비트(sign bit)가 있기 때문에, -128부터 127까지의 범위로 해석됩니다. 이때, 0은 0으로 인식됩니다.
        부호 없는 (Unsigned) Byte: 이 경우, 0에서 255까지의 값을 가질 수 있습니다.
            부호 비트가 없기 때문에 0부터 255까지 모두 양의 정수로 해석됩니다.
        */

        /// sha1 = 128bit를 쓴다.
        MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
        String pwSha1 = new BigInteger(1, sha1.digest(pw.getBytes())).toString(16);
        System.out.println(pwSha1);  // 4afa71ffb32dc64586c1a3b65cb7b99d7f2e3185

        /// sha256 = 256bit를 쓴다.
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
        String pwSha2 = new BigInteger(1, sha256.digest(pw.getBytes())).toString(16);
        System.out.println(pwSha2);  // e8f817f346d1d411cc59d5bdda64fab3763890e1f0f8f4c15805cf78874d68bf

        // BCrypt
        /*
         비밀번호 해싱을 위한 알고리즘. BCrypt는 사용자의 비밀번호를 안전하게 저장하는 데 사용
         BCrypt는 비밀번호를 해싱하여 저장하고 복호화할 수 없음. 즉, 복원할 수 없기 때문에 해커가 데이터를 훔쳐도 원본 비밀번호를 알 수 없음
         소금(Salt); BCrypt의 중요한 특징 중 하나는 소금(Salt)입니다.
         소금은 랜덤한 값을 말하는데, 이것을 비밀번호와 결합해서 해싱합니다. 이렇게 하면 동일한 비밀번호라도 매번 다른 해시값을 생성할 수 있습니다.

        >> BCrypt의 특징
        - 단방향 해시: 한 번 해싱된 비밀번호는 복원할 수 없습니다. 즉, 암호화된 비밀번호는 복호화할 수 없습니다.
        - 소금(Salt) 적용: 매번 다른 소금을 사용해서 같은 비밀번호라도 다른 해시값을 만듭니다.
        - 느린 속도: BCrypt는 해싱 과정을 일부러 느리게 만들어, 해커가 무차별 대입 공격(모든 가능한 비밀번호를 시도하는 공격)을 시도하는 데 더 많은 시간이 걸리게 만듭니다.

        어떻게 사용되나요?
        사용자가 비밀번호를 입력하면, **랜덤 소금(salt)**을 생성합니다.
        그 소금을 비밀번호와 결합하여 해시를 만듭니다.
        그 해시값을 데이터베이스에 저장합니다.
        사용자가 로그인할 때, 입력한 비밀번호를 같은 방법으로 해싱하고, 저장된 해시값과 비교하여 맞는지 확인합니다.

         */

        String pwBcrypt= BCrypt.hashpw(pw, BCrypt.gensalt());
        System.out.println(pwBcrypt);
        // $2a$10$crssNGYF4JCzztyq/ap9nebEB/ZXkhjlyV6o47Ibd03IXZpulrvNa
        // $2a $10 $crssNGYF4JCzztyq/ap9nebEB/ZXkhjlyV6o47Ibd03IXZpulrvNa
        String pwBcrypt2 = BCrypt.hashpw(pw, BCrypt.gensalt());
        System.out.println(pwBcrypt2);
        // $2a$10$eWReaVFhq.PA04YzwX9MzO32BPPnOjbW5PorTKbyOTGUkC.FgTfy2
        // $2a $10 $eWReaVFhq.PA04YzwX9MzO32BPPnOjbW5PorTKbyOTGUkC.FgTfy2
        // 할때마다 다른 값이 나옴
        // 구조
        // $2a ;2a가 해시함수의 버전
        // $10 ;10은 몇 번 반복해서 해시 함수를 만들었나
        // $eWReaVFh ; eWReaVFh솔트. 해시함수를 만들 때 사용한 키

        // 할때마다 다른 값이 나옴. 매번 솔트와 연산 수에 의해 다른 값이 반환.
        // (키와 연산 수가 공개되어 있음 -> 공개키
        System.out.println(BCrypt.checkpw("안녕", pwBcrypt));
        System.out.println(BCrypt.checkpw("안녕", pwBcrypt2));
        System.out.println(BCrypt.checkpw("1234", pwBcrypt2));

        // BCrypt의 등장배경
        // MD5, SHA1, SHA2의 취약점
        // 1) 서로 다른 입력값이 동일한 값으로 암호화될 가능성(해시충돌Hash collision)
        // 2) 해시함수의 연산이 수평적)
        // 해킹가능 1) 동일한 값이라는 측면에서 => 무작위 값(무차별 값) 대입, => 어쩌다가 하나 걸림
        // 해킹가능 2) 연산이 수평적이다? => GPU를 이용해서 한번에 계산해서 해시함수를 풀어버림 (레인보우 테이블)
        // BCrypt 1) 매번 바뀜 => 무차별 값 대입이 불가능.
        // BCrypt 2) 솔트로 인해서 순차적 연산을 해야 해시 함수가 나옴 => 수평적 연산이 불가능

        /*
        MD5, SHA1, SHA2 등의 해시 함수들은 주로 데이터를 일정 길이의 고유한 값으로 변환하는데 사용
        파일을 해시 함수를 사용해서 해시 값을 생성하면, 이 해시 값이 해당 파일을 대표하는 "지문"처럼 작용
        문제점 두개.
        1) 해시 충돌(Hash collision) 이란, 서로 다른 입력값이 동일한 해시 값을 생성하는 현상
        2) 해시 함수의 구조가 비교적 간단하다는 의미로 볼 수 있습니다. 즉, 해시 함수가 입력 데이터를 처리하는 과정에서 반복적인 연산이나 복잡한 계산을 하지 않고, 일정한 규칙에 따라 고정된 길이의 결과 값을 생성하는 방식

        1. 동일한 값으로 암호화되는 문제 (해시 충돌 문제)
            Bcrypt는 "솔트(salt)"를 사용합니다.
            솔트는 해시 함수를 적용하기 전에 각 입력값에 추가되는 랜덤한 문자열입니다. 예를 들어, 동일한 비밀번호라도 사용자마다 다른 솔트를 사용하면, 서로 다른 해시 값을 생성합니다. 따라서, 같은 비밀번호를 입력하더라도, 솔트가 다르면 생성되는 해시 값이 달라져서 해시 충돌을 방지할 수 있습니다. 이렇게 하면 해시 충돌이 발생할 가능성이 극도로 낮아지죠.
            예를 들어, 사용자 A와 사용자 B가 동일한 비밀번호를 가질지라도, Bcrypt는 두 사람에게 각각 다른 솔트를 추가하여 각자 다른 해시 값을 생성하게 만듭니다. 이렇게 하면 해시 충돌이 일어날 가능성이 없으므로 보안성이 높아집니다.

        2. 해시 함수의 연산이 수평적 문제 (연산 속도 및 복잡도)
            **Bcrypt는 "비용 인자(cost factor)"**를 사용하여 연산의 복잡도를 조절할 수 있습니다.
            Bcrypt는 해시 계산을 더 느리게 할 수 있도록 설계되어 있습니다. 이를 통해 **무차별 대입 공격(brute force attack)**이나 **사전 공격(dictionary attack)**을 방어하는데 도움이 됩니다. Bcrypt는 해시 계산을 의도적으로 느리게 만듭니다. 예를 들어, "비용 인자"를 10으로 설정하면, 해시 연산을 2^10번 반복하고, 이를 통해 계산 속도를 조절할 수 있습니다.
            이 방식은 해시 함수를 "수평적"이 아닌 "수직적"으로 복잡하게 만들어, 공격자가 비밀번호를 빠르게 추측할 수 없도록 만듭니다. 쉽게 말해, Bcrypt는 비밀번호를 암호화할 때 계산을 더 오래 걸리게 하여, 해커가 해시 값을 추측하기 위한 연산을 훨씬 더 어렵게 만듭니다.
         */


        System.out.println(BCrypt.hashpw("1234", BCrypt.gensalt()));
        // 1234와 다른 솔트로 조합하여 만든 해쉬값.
        String hash1 = "$2a$10$.B0gPYHAY0IZvZEc4lKfg.HhTGKJrcjdaI2dwjkbntPVPjSKtjrSO";
        String hash2 = "$2a$10$hxjZa.qXt24Hl1tU50qs.Oqo38r1OgH1GkBxwUUrL6DRT8wRpuemW";
        // 동일한지 묻기
        System.out.println(BCrypt.checkpw(hash1, hash2)); // false 평문(==그냥 데이터, 1234)이 아니면 비교 불가
        System.out.println(BCrypt.checkpw("1234", hash2)); // true
        System.out.println(BCrypt.checkpw("1234", hash2)); // true
    }
}

/*
개발에 있어서 숫자를 표현하는 방식은 셋이있다.

"안" -> Utf8(16진수)로 변환하면 3바이트짜리 16진수로 된 수 0xEC 0x95 0x88
(0x의 의미는 "16진수"(Hexadecimal)를 나타내는 접두사로, 숫자가 16진수로 표현되고 있음을 명시하는 용도로 사용)
(16진수란 2^4, 즉 2진수 네 자리수 0000를 의미함)
(16*16는 256. 따라서 2자리 16진수가 표현할 수 있는 값은 0부터 255까지의 범위다. 256이 또한 2^8, 1바이트가 가질 수 있는 최대 값이다.
1바이트를 설명할 때 주로 16진수 두자리수로 표현함
따라서 16진수로 2자리는 8비트(1바이트) 범위 내의 값을 정확히 표현할 수 있기 때문에, 각 바이트를 2자리 16진수로 나타내는 것)
->  0xEC 0x95 0x88 를 다시 2진수로 변환하면  11101100, 10010101, 10001000
->  0xEC 0x95 0x88 를 Java에서 byte 타입으로 처리하면, 각각 -20, -107, -120으로 표현



왜 ?

Java에서 byte 타입의 값 처리 방식의 특징.
음수로 표현되는 이유는 부호 있는 바이트(signed byte)이기 때문.
byte는 -128에서 127까지의 범위만을 가질 수 있습니다.
그런데 0xEC, 0x95, 0x88은 16진수 값이고, 이를 부호 있는 바이트로 해석하면 음수로 변환.

왜? 0xEC → -20
0xEC는 16진수 값입니다. 이를 10진수로 바꾸면 236입니다.
그런데, byte 타입은 8비트 부호 있는 정수이므로, 값의 범위는 -128에서 127까지입니다.
236은 이 범위를 초과하므로, byte로 변환할 때 부호 있는 값으로 해석되면 음수가 됩니다.
236 - 256 = -20이므로, 0xEC는 -20으로 변환됩니다.
같은 방식으로
0x95는 149를 10진수로 바꾼 값으로, 부호 있는 바이트로 변환되면 -107이 됩니다.
0x88은 136을 10진수로 바꾼 값으로, 부호 있는 바이트로 변환되면 -120이 됩니다.

 */

/*
해쉬작업을 진행하다가 보수연산 또는 비트이동 연산을 진행하면서
1) 값이 손실됨. 그리고 2) 같은 값을 가지게 될 가능성이 됨.
그래서 다시 되돌릴 수 없음. 그래서 단방향이됨,


 */